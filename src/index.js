const axios = require('axios')
const NodeCache = require('node-cache')
const path = require('path')

const PROJECT_CACHE_TTL = 60 * 60 * 24 // 24 Hours
const LANGUAGE_CACHE_TTL = 60 * 10 // 10 Minutes

const projectKey = 'WTI::TRANSLATIONS::PROJECT'

const cache = new NodeCache({ checkperiod: 240, deleteOnExpire: false })

const httpClient = axios.create({
  baseURL: 'https://webtranslateit.com/api/projects',
  timeout: 3000
})

const locked = new Set([])

const fetchProject = async token => {
  let res
  try {
    const response = await httpClient.get(`/${token}`)

    const {
      data: { project }
    } = response

    res = project
    cache.set(projectKey, project, PROJECT_CACHE_TTL)
  } catch (e) {
    console.log('Could not fetch WTI project', token)
    console.log(e)
  }

  return res
}

const fetchTranslation = async (token, file) => {
  const { master_project_file_id: masterId, locale_code: locale, id } = file
  const fileId = masterId || id
  let translation = {}

  try {
    const response = await httpClient.get(
      `/${token}/files/${fileId}/locales/${locale}`
    )

    translation = response.data
  } catch (e) {
    console.log('Could not fetch WTI translation for', locale)
  }

  return translation
}

const fetchData = async (token, locale) => {
  let project = cache.get(projectKey)
  if (!project || !project.project_files) {
    project = await fetchProject(token)
  }

  const { project_files: files } = project

  const file =
    files.find(f => f.locale_code === locale) ||
    files.find(f => f.locale_code === 'en')

  const translation = await fetchTranslation(token, file)

  return translation
}

/**
 * @param config
 *  {
 *    projectToken : The token generated by your webtranslate project,
 *    ttl : Cache time in seconds
 *    plainFunction : return plain function or middleware function
 *  }
 * @returns function
 */
module.exports = ({
  projectToken,
  ttl = LANGUAGE_CACHE_TTL,
  plainFunction = false
}) => {
  cache.on('expired', async (key, value) => {
    if (locked.has(key)) {
      return
    }
    locked.add(key)
    if (key === projectKey) {
      await fetchProject(projectToken)
    } else {
      const locale = key.split('WTI::TRANSLATIONS::')[1]
      const data = await fetchData(projectToken, locale)
      if (data && Object.keys(data).length) {
        cache.set(key, data, ttl)
      }
    }
    locked.delete(key)
  })

  if (plainFunction) {
    return async locale => {
      const key = `WTI::TRANSLATIONS::${locale}`

      let data
      const cachedVal = cache.get(key)

      if (!cachedVal) {
        data = await fetchData(projectToken, locale)
        cache.set(key, data, ttl)
      }

      return cachedVal || data
    }
  }

  return async (req, res, next) => {
    if (path.extname(req.path)) {
      return next()
    }

    const { wti_locale: locale } = req.headers
    const key = `WTI::TRANSLATIONS::${locale}`

    let data
    const cachedVal = cache.get(key)

    if (!cachedVal) {
      data = await fetchData(projectToken, locale)
      cache.set(key, data, ttl)
    }

    req.translations = cachedVal || data

    return next()
  }
}
